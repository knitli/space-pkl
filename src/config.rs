//! Configuration types for the schema generator.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Configuration for the schema generator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratorConfig {
    /// Whether to include comments in generated schemas
    pub include_comments: bool,
    
    /// Whether to include example values
    pub include_examples: bool,
    
    /// Whether to include validation constraints
    pub include_validation: bool,
    
    /// Custom header to prepend to generated files
    pub header: Option<String>,
    
    /// Custom footer to append to generated files
    pub footer: Option<String>,
    
    /// Output directory for generated files
    pub output_dir: PathBuf,
    
    /// Module name for generated schemas
    pub module_name: String,
    
    /// Whether to generate individual type files or a single module
    pub split_types: bool,
    
    /// Custom type mappings for schema generation
    pub type_mappings: HashMap<String, String>,
    
    /// Template configuration
    pub template: TemplateConfig,
}

impl Default for GeneratorConfig {
    fn default() -> Self {
        Self {
            include_comments: true,
            include_examples: true,
            include_validation: true,
            header: Some(default_header()),
            footer: None,
            output_dir: PathBuf::from("./pkl-schemas"),
            module_name: "moon".to_string(),
            split_types: true,
            type_mappings: default_type_mappings(),
            template: TemplateConfig::default(),
        }
    }
}

/// Template configuration for schema generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateConfig {
    /// Base template directory
    pub template_dir: Option<PathBuf>,
    
    /// Custom templates for specific types
    pub custom_templates: HashMap<String, String>,
    
    /// Whether to generate template files alongside schemas
    pub generate_templates: bool,
    
    /// Template file extension
    pub template_extension: String,
}

impl Default for TemplateConfig {
    fn default() -> Self {
        Self {
            template_dir: None,
            custom_templates: HashMap::new(),
            generate_templates: true,
            template_extension: "pkl".to_string(),
        }
    }
}

/// Schema type to generate
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SchemaType {
    /// Workspace configuration schema
    Workspace,
    /// Project configuration schema
    Project,
    /// Template configuration schema
    Template,
    /// Toolchain configuration schema
    Toolchain,
    /// Tasks configuration schema
    Tasks,
    /// All schema types
    All,
}

impl SchemaType {
    /// Get the filename for this schema type
    pub fn filename(&self) -> &'static str {
        match self {
            Self::Workspace => "workspace.pkl",
            Self::Project => "project.pkl",
            Self::Template => "template.pkl",
            Self::Toolchain => "toolchain.pkl",
            Self::Tasks => "tasks.pkl",
            Self::All => unreachable!("All is not a single file"),
        }
    }
    
    /// Get the module name for this schema type
    pub fn module_name(&self) -> &'static str {
        match self {
            Self::Workspace => "Workspace",
            Self::Project => "Project",
            Self::Template => "Template",
            Self::Toolchain => "Toolchain",
            Self::Tasks => "Tasks",
            Self::All => unreachable!("All is not a single module"),
        }
    }
}

fn default_header() -> String {
    format!(
        r#"//! Moon Configuration Schema for Pkl
//! 
//! Generated by space-pkl v{}
//! Source: https://github.com/knitli/space-pkl
//! Moon: https://github.com/moonrepo/moon
//! 
//! This schema provides type-safe configuration authoring for Moon workspace management.

"#,
        env!("CARGO_PKG_VERSION")
    )
}

fn default_type_mappings() -> HashMap<String, String> {
    let mut mappings = HashMap::new();
    
    // Common Rust -> Pkl type mappings
    mappings.insert("String".to_string(), "String".to_string());
    mappings.insert("bool".to_string(), "Boolean".to_string());
    mappings.insert("i32".to_string(), "Int".to_string());
    mappings.insert("i64".to_string(), "Int".to_string());
    mappings.insert("u32".to_string(), "UInt".to_string());
    mappings.insert("u64".to_string(), "UInt".to_string());
    mappings.insert("f32".to_string(), "Float".to_string());
    mappings.insert("f64".to_string(), "Float".to_string());
    mappings.insert("Vec".to_string(), "Listing".to_string());
    mappings.insert("HashMap".to_string(), "Mapping".to_string());
    mappings.insert("BTreeMap".to_string(), "Mapping".to_string());
    mappings.insert("Option".to_string(), "".to_string()); // Optional in Pkl
    
    mappings
}
